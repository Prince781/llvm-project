; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; ## Full FP32x2 support enabled by default.
; RUN: llc < %s -mtriple=nvptx64-nvidia-cuda -mcpu=sm_100                      \
; RUN:         -O0 -disable-post-ra -frame-pointer=all -verify-machineinstrs   \
; RUN: | FileCheck --check-prefixes=CHECK-O0 %s
; RUN: %if ptxas %{                                                            \
; RUN:  llc < %s -mtriple=nvptx64-nvidia-cuda -mcpu=sm_100                     \
; RUN:           -O0 -disable-post-ra -frame-pointer=all -verify-machineinstrs \
; RUN:  | %ptxas-verify -arch=sm_100                                           \
; RUN: %}
; RUN: llc < %s -mtriple=nvptx64-nvidia-cuda -mcpu=sm_100                      \
; RUN:         -O3 -verify-machineinstrs                                       \
; RUN: | FileCheck --check-prefixes=CHECK-O3 %s
; RUN: %if ptxas %{                                                            \
; RUN:  llc < %s -mtriple=nvptx64-nvidia-cuda -mcpu=sm_100                     \
; RUN:           -O3 -verify-machineinstrs                                     \
; RUN:  | %ptxas-verify -arch=sm_100                                           \
; RUN: %}

target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "nvptx64-nvidia-cuda"

define <2 x float> @test_ret_const() #0 {
  ret <2 x float> <float 1.0, float 2.0>
}

define float @test_extract_0(<2 x float> %a) #0 {
  %e = extractelement <2 x float> %a, i32 0
  ret float %e
}

define float @test_extract_1(<2 x float> %a) #0 {
  %e = extractelement <2 x float> %a, i32 1
  ret float %e
}

; NOTE: disabled as -O3 miscompiles this into pointer arithmetic on
; test_extract_i_param_0 where the symbol's address is not taken first (that
; is, moved to a temporary)
; define float @test_extract_i(<2 x float> %a, i64 %idx) #0 {
; ; CHECK-LABEL: test_extract_i(
; ; CHECK:       {
; ; CHECK-NEXT:    .reg .pred %p<2>;
; ; CHECK-NEXT:    .reg .f32 %f<4>;
; ; CHECK-NEXT:    .reg .b64 %rd<2>;
; ; CHECK-EMPTY:
; ; CHECK-NEXT:  // %bb.0:
; ; CHECK-NEXT:    ld.param.v2.f32 {%f1, %f2}, [test_extract_i_param_0];
; ; CHECK-NEXT:    ld.param.u64 %rd1, [test_extract_i_param_1];
; ; CHECK-NEXT:    setp.eq.s64 %p1, %rd1, 0;
; ; CHECK-NEXT:    selp.f32 %f3, %f1, %f2, %p1;
; ; CHECK-NEXT:    st.param.f32 [func_retval0], %f3;
; ; CHECK-NEXT:    ret;
;   %e = extractelement <2 x float> %a, i64 %idx
;   ret float %e
; }

define <2 x float> @test_fadd(<2 x float> %a, <2 x float> %b) #0 {
  %r = fadd <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fadd_imm_0(<2 x float> %a) #0 {
  %r = fadd <2 x float> <float 1.0, float 2.0>, %a
  ret <2 x float> %r
}

define <2 x float> @test_fadd_imm_1(<2 x float> %a) #0 {
  %r = fadd <2 x float> %a, <float 1.0, float 2.0>
  ret <2 x float> %r
}

define <4 x float> @test_fadd_v4(<4 x float> %a, <4 x float> %b) #0 {
  %r = fadd <4 x float> %a, %b
  ret <4 x float> %r
}

define <4 x float> @test_fadd_imm_0_v4(<4 x float> %a) #0 {
  %r = fadd <4 x float> <float 1.0, float 2.0, float 3.0, float 4.0>, %a
  ret <4 x float> %r
}

define <4 x float> @test_fadd_imm_1_v4(<4 x float> %a) #0 {
  %r = fadd <4 x float> %a, <float 1.0, float 2.0, float 3.0, float 4.0>
  ret <4 x float> %r
}

define <2 x float> @test_fsub(<2 x float> %a, <2 x float> %b) #0 {
  %r = fsub <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fneg(<2 x float> %a) #0 {
  %r = fsub <2 x float> <float 0.0, float 0.0>, %a
  ret <2 x float> %r
}

define <2 x float> @test_fmul(<2 x float> %a, <2 x float> %b) #0 {
  %r = fmul <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fma(<2 x float> %a, <2 x float> %b, <2 x float> %c) #0 {
  %r = call <2 x float> @llvm.fma(<2 x float> %a, <2 x float> %b, <2 x float> %c)
  ret <2 x float> %r
}

define <2 x float> @test_fdiv(<2 x float> %a, <2 x float> %b) #0 {
  %r = fdiv <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_frem(<2 x float> %a, <2 x float> %b) #0 {
  %r = frem <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fadd_ftz(<2 x float> %a, <2 x float> %b) #2 {
  %r = fadd <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fadd_imm_0_ftz(<2 x float> %a) #2 {
  %r = fadd <2 x float> <float 1.0, float 2.0>, %a
  ret <2 x float> %r
}

define <2 x float> @test_fadd_imm_1_ftz(<2 x float> %a) #2 {
  %r = fadd <2 x float> %a, <float 1.0, float 2.0>
  ret <2 x float> %r
}

define <4 x float> @test_fadd_v4_ftz(<4 x float> %a, <4 x float> %b) #2 {
  %r = fadd <4 x float> %a, %b
  ret <4 x float> %r
}

define <4 x float> @test_fadd_imm_0_v4_ftz(<4 x float> %a) #2 {
  %r = fadd <4 x float> <float 1.0, float 2.0, float 3.0, float 4.0>, %a
  ret <4 x float> %r
}

define <4 x float> @test_fadd_imm_1_v4_ftz(<4 x float> %a) #2 {
  %r = fadd <4 x float> %a, <float 1.0, float 2.0, float 3.0, float 4.0>
  ret <4 x float> %r
}

define <2 x float> @test_fsub_ftz(<2 x float> %a, <2 x float> %b) #2 {
  %r = fsub <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fneg_ftz(<2 x float> %a) #2 {
  %r = fsub <2 x float> <float 0.0, float 0.0>, %a
  ret <2 x float> %r
}

define <2 x float> @test_fmul_ftz(<2 x float> %a, <2 x float> %b) #2 {
  %r = fmul <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_fma_ftz(<2 x float> %a, <2 x float> %b, <2 x float> %c) #2 {
  %r = call <2 x float> @llvm.fma(<2 x float> %a, <2 x float> %b, <2 x float> %c)
  ret <2 x float> %r
}

define <2 x float> @test_fdiv_ftz(<2 x float> %a, <2 x float> %b) #2 {
  %r = fdiv <2 x float> %a, %b
  ret <2 x float> %r
}

define <2 x float> @test_frem_ftz(<2 x float> %a, <2 x float> %b) #2 {
  %r = frem <2 x float> %a, %b
  ret <2 x float> %r
}

define void @test_ldst_v2f32(ptr %a, ptr %b) #0 {
  %t1 = load <2 x float>, ptr %a
  store <2 x float> %t1, ptr %b, align 32
  ret void
}

define void @test_ldst_v3f32(ptr %a, ptr %b) #0 {
  %t1 = load <3 x float>, ptr %a
  store <3 x float> %t1, ptr %b, align 32
  ret void
}

define void @test_ldst_v4f32(ptr %a, ptr %b) #0 {
  %t1 = load <4 x float>, ptr %a
  store <4 x float> %t1, ptr %b, align 32
  ret void
}

define void @test_ldst_v8f32(ptr %a, ptr %b) #0 {
  %t1 = load <8 x float>, ptr %a
  store <8 x float> %t1, ptr %b, align 32
  ret void
}

declare <2 x float> @test_callee(<2 x float> %a, <2 x float> %b) #0

define <2 x float> @test_call(<2 x float> %a, <2 x float> %b) #0 {
  %r = call <2 x float> @test_callee(<2 x float> %a, <2 x float> %b)
  ret <2 x float> %r
}

define <2 x float> @test_call_flipped(<2 x float> %a, <2 x float> %b) #0 {
  %r = call <2 x float> @test_callee(<2 x float> %b, <2 x float> %a)
  ret <2 x float> %r
}

define <2 x float> @test_tailcall_flipped(<2 x float> %a, <2 x float> %b) #0 {
  %r = tail call <2 x float> @test_callee(<2 x float> %b, <2 x float> %a)
  ret <2 x float> %r
}

define <2 x float> @test_select(<2 x float> %a, <2 x float> %b, i1 zeroext %c) #0 {
  %r = select i1 %c, <2 x float> %a, <2 x float> %b
  ret <2 x float> %r
}

define <2 x float> @test_select_cc(<2 x float> %a, <2 x float> %b, <2 x float> %c, <2 x float> %d) #0 {
  %cc = fcmp une <2 x float> %c, %d
  %r = select <2 x i1> %cc, <2 x float> %a, <2 x float> %b
  ret <2 x float> %r
}

define <2 x double> @test_select_cc_f64_f32(<2 x double> %a, <2 x double> %b, <2 x float> %c, <2 x float> %d) #0 {
  %cc = fcmp une <2 x float> %c, %d
  %r = select <2 x i1> %cc, <2 x double> %a, <2 x double> %b
  ret <2 x double> %r
}

define <2 x float> @test_select_cc_f32_f64(<2 x float> %a, <2 x float> %b, <2 x double> %c, <2 x double> %d) #0 {
  %cc = fcmp une <2 x double> %c, %d
  %r = select <2 x i1> %cc, <2 x float> %a, <2 x float> %b
  ret <2 x float> %r
}

define <2 x i1> @test_fcmp_une(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp une <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ueq(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ueq <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ugt(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ugt <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_uge(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp uge <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ult(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ult <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ule(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ule <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_uno(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp uno <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_one(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp one <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_oeq(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp oeq <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ogt(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ogt <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_oge(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp oge <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_olt(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp olt <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ole(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ole <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i1> @test_fcmp_ord(<2 x float> %a, <2 x float> %b) #0 {
  %r = fcmp ord <2 x float> %a, %b
  ret <2 x i1> %r
}

define <2 x i32> @test_fptosi_i32(<2 x float> %a) #0 {
  %r = fptosi <2 x float> %a to <2 x i32>
  ret <2 x i32> %r
}

define <2 x i64> @test_fptosi_i64(<2 x float> %a) #0 {
  %r = fptosi <2 x float> %a to <2 x i64>
  ret <2 x i64> %r
}

define <2 x i32> @test_fptoui_2xi32(<2 x float> %a) #0 {
  %r = fptoui <2 x float> %a to <2 x i32>
  ret <2 x i32> %r
}

define <2 x i64> @test_fptoui_2xi64(<2 x float> %a) #0 {
  %r = fptoui <2 x float> %a to <2 x i64>
  ret <2 x i64> %r
}

define <2 x float> @test_uitofp_2xi32(<2 x i32> %a) #0 {
  %r = uitofp <2 x i32> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x float> @test_uitofp_2xi64(<2 x i64> %a) #0 {
  %r = uitofp <2 x i64> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x float> @test_sitofp_2xi32(<2 x i32> %a) #0 {
  %r = sitofp <2 x i32> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x float> @test_sitofp_2xi64(<2 x i64> %a) #0 {
  %r = sitofp <2 x i64> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x float> @test_uitofp_2xi32_fadd(<2 x i32> %a, <2 x float> %b) #0 {
  %c = uitofp <2 x i32> %a to <2 x float>
  %r = fadd <2 x float> %b, %c
  ret <2 x float> %r
}

define <2 x float> @test_fptrunc_2xdouble(<2 x double> %a) #0 {
  %r = fptrunc <2 x double> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x double> @test_fpext_2xdouble(<2 x float> %a) #0 {
  %r = fpext <2 x float> %a to <2 x double>
  ret <2 x double> %r
}

define <2 x i32> @test_bitcast_2xfloat_to_2xi32(<2 x float> %a) #0 {
  %r = bitcast <2 x float> %a to <2 x i32>
  ret <2 x i32> %r
}

define <2 x float> @test_bitcast_2xi32_to_2xfloat(<2 x i32> %a) #0 {
  %r = bitcast <2 x i32> %a to <2 x float>
  ret <2 x float> %r
}

define <2 x float> @test_bitcast_double_to_2xfloat(double %a) #0 {
  %r = bitcast double %a to <2 x float>
  ret <2 x float> %r
}

define double @test_bitcast_2xfloat_to_double(<2 x float> %a) #0 {
  %r = bitcast <2 x float> %a to double
  ret double %r
}

attributes #0 = { nounwind }
attributes #1 = { "unsafe-fp-math" = "true" }
attributes #2 = { "denormal-fp-math"="preserve-sign" }
