; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mcpu=sm_20 | FileCheck %s
; RUN: %if ptxas %{ llc < %s -mcpu=sm_20 | %ptxas-verify %}
target triple = "nvptx64-nvidia-cuda"

; Test dynamic insertelt at the beginning of a chain
define <4 x i32> @dynamic_at_beginning(i32 %idx) {
; CHECK-LABEL: dynamic_at_beginning(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot0[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<3>;
; CHECK-NEXT:    .reg .b64 %rd<6>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot0;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [dynamic_at_beginning_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r2, 20, 30, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 1
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 2
  ret <4 x i32> %v2
}

; Test dynamic insertelt at the end of a chain
define <4 x i32> @dynamic_at_end(i32 %idx) {
; CHECK-LABEL: dynamic_at_end(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot1[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .b64 %rd<6>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot1;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [dynamic_at_end_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%SP+4], 20;
; CHECK-NEXT:    st.b32 [%SP], 10;
; CHECK-NEXT:    st.b32 [%rd5], 30;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+8];
; CHECK-NEXT:    ld.b32 %r3, [%SP+4];
; CHECK-NEXT:    ld.b32 %r4, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r4, %r3, %r2, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 1
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 %idx
  ret <4 x i32> %v2
}

; Test dynamic insertelt in the middle of a chain
define <4 x i32> @dynamic_in_middle(i32 %idx) {
; CHECK-LABEL: dynamic_in_middle(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot2[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<4>;
; CHECK-NEXT:    .reg .b64 %rd<6>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot2;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [dynamic_in_middle_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%SP], 10;
; CHECK-NEXT:    st.b32 [%rd5], 20;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+4];
; CHECK-NEXT:    ld.b32 %r3, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r3, %r2, 30, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 %idx
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 2
  ret <4 x i32> %v2
}

; Test repeated dynamic insertelt with the same index
define <4 x i32> @repeated_same_index(i32 %idx) {
; CHECK-LABEL: repeated_same_index(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot3[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .b64 %rd<6>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot3;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [repeated_same_index_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 20;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+8];
; CHECK-NEXT:    ld.b32 %r3, [%SP+4];
; CHECK-NEXT:    ld.b32 %r4, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r4, %r3, %r2, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 %idx
  ret <4 x i32> %v1
}

; Test multiple dynamic insertelts
define <4 x i32> @multiple_dynamic(i32 %idx0, i32 %idx1) {
; CHECK-LABEL: multiple_dynamic(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot4[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .b64 %rd<10>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot4;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [multiple_dynamic_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    ld.param.b32 %rd6, [multiple_dynamic_param_1];
; CHECK-NEXT:    and.b64 %rd7, %rd6, 3;
; CHECK-NEXT:    shl.b64 %rd8, %rd7, 2;
; CHECK-NEXT:    add.s64 %rd9, %rd4, %rd8;
; CHECK-NEXT:    st.b32 [%rd9], 20;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+8];
; CHECK-NEXT:    ld.b32 %r3, [%SP+4];
; CHECK-NEXT:    ld.b32 %r4, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r4, %r3, %r2, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 %idx1
  ret <4 x i32> %v1
}

; Test chain with all dynamic insertelts
define <4 x i32> @all_dynamic(i32 %idx0, i32 %idx1, i32 %idx2, i32 %idx3) {
; CHECK-LABEL: all_dynamic(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot5[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .b64 %rd<18>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot5;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [all_dynamic_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    ld.param.b32 %rd6, [all_dynamic_param_1];
; CHECK-NEXT:    and.b64 %rd7, %rd6, 3;
; CHECK-NEXT:    shl.b64 %rd8, %rd7, 2;
; CHECK-NEXT:    add.s64 %rd9, %rd4, %rd8;
; CHECK-NEXT:    ld.param.b32 %rd10, [all_dynamic_param_2];
; CHECK-NEXT:    and.b64 %rd11, %rd10, 3;
; CHECK-NEXT:    shl.b64 %rd12, %rd11, 2;
; CHECK-NEXT:    add.s64 %rd13, %rd4, %rd12;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    st.b32 [%rd9], 20;
; CHECK-NEXT:    st.b32 [%rd13], 30;
; CHECK-NEXT:    ld.param.b32 %rd14, [all_dynamic_param_3];
; CHECK-NEXT:    and.b64 %rd15, %rd14, 3;
; CHECK-NEXT:    shl.b64 %rd16, %rd15, 2;
; CHECK-NEXT:    add.s64 %rd17, %rd4, %rd16;
; CHECK-NEXT:    st.b32 [%rd17], 40;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+8];
; CHECK-NEXT:    ld.b32 %r3, [%SP+4];
; CHECK-NEXT:    ld.b32 %r4, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r4, %r3, %r2, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 %idx1
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 %idx2
  %v3 = insertelement <4 x i32> %v2, i32 40, i32 %idx3
  ret <4 x i32> %v3
}

; Test mixed constant and dynamic insertelts with high ratio of dynamic ones.
; Should lower all insertelts to stores.
define <4 x i32> @mix_high_dynamic_ratio(i32 %idx0, i32 %idx1) {
; CHECK-LABEL: mix_high_dynamic_ratio(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot6[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .b64 %rd<10>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot6;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [mix_high_dynamic_ratio_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    ld.param.b32 %rd6, [mix_high_dynamic_ratio_param_1];
; CHECK-NEXT:    and.b64 %rd7, %rd6, 3;
; CHECK-NEXT:    shl.b64 %rd8, %rd7, 2;
; CHECK-NEXT:    add.s64 %rd9, %rd4, %rd8;
; CHECK-NEXT:    st.b32 [%SP+4], 20;
; CHECK-NEXT:    st.b32 [%rd9], 30;
; CHECK-NEXT:    ld.b32 %r1, [%SP+12];
; CHECK-NEXT:    ld.b32 %r2, [%SP+8];
; CHECK-NEXT:    ld.b32 %r3, [%SP+4];
; CHECK-NEXT:    ld.b32 %r4, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r4, %r3, %r2, %r1};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 1
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 %idx1
  ret <4 x i32> %v2
}

; Test mixed constant and dynamic insertelts with low ratio of dynamic ones.
; Should handle dynamic insertelt individually.
define <4 x i32> @mix_low_dynamic_ratio(i32 %idx) {
; CHECK-LABEL: mix_low_dynamic_ratio(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot7[16];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<3>;
; CHECK-NEXT:    .reg .b64 %rd<6>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot7;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [mix_low_dynamic_ratio_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 0;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%SP], 10;
; CHECK-NEXT:    st.b32 [%rd5], 20;
; CHECK-NEXT:    ld.b32 %r1, [%SP+4];
; CHECK-NEXT:    ld.b32 %r2, [%SP];
; CHECK-NEXT:    st.param.v4.b32 [func_retval0], {%r2, %r1, 30, 40};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 %idx
  %v2 = insertelement <4 x i32> %v1, i32 30, i32 2
  %v3 = insertelement <4 x i32> %v2, i32 40, i32 3
  ret <4 x i32> %v3
}

; Test two separate chains that don't interfere
define void @two_separate_chains(i32 %idx0, i32 %idx1, ptr %out0, ptr %out1) {
; CHECK-LABEL: two_separate_chains(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot8[32];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<7>;
; CHECK-NEXT:    .reg .b64 %rd<13>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot8;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [two_separate_chains_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 16;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    ld.param.b32 %rd6, [two_separate_chains_param_1];
; CHECK-NEXT:    and.b64 %rd7, %rd6, 3;
; CHECK-NEXT:    shl.b64 %rd8, %rd7, 2;
; CHECK-NEXT:    add.u64 %rd9, %SP, 0;
; CHECK-NEXT:    add.s64 %rd10, %rd9, %rd8;
; CHECK-NEXT:    ld.b32 %r1, [%SP+28];
; CHECK-NEXT:    ld.b32 %r2, [%SP+24];
; CHECK-NEXT:    ld.b32 %r3, [%SP+16];
; CHECK-NEXT:    ld.param.b64 %rd11, [two_separate_chains_param_2];
; CHECK-NEXT:    st.b32 [%rd10], 30;
; CHECK-NEXT:    ld.param.b64 %rd12, [two_separate_chains_param_3];
; CHECK-NEXT:    ld.b32 %r4, [%SP+12];
; CHECK-NEXT:    ld.b32 %r5, [%SP+4];
; CHECK-NEXT:    ld.b32 %r6, [%SP];
; CHECK-NEXT:    st.v4.b32 [%rd11], {%r3, 20, %r2, %r1};
; CHECK-NEXT:    st.v4.b32 [%rd12], {%r6, %r5, 40, %r4};
; CHECK-NEXT:    ret;
  ; Chain 1
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 1

  ; Chain 2
  %w0 = insertelement <4 x i32> poison, i32 30, i32 %idx1
  %w1 = insertelement <4 x i32> %w0, i32 40, i32 2

  store <4 x i32> %v1, ptr %out0
  store <4 x i32> %w1, ptr %out1
  ret void
}

; Test overlapping chains (chain 2 starts from middle of chain 1)
define void @overlapping_chains(i32 %idx0, i32 %idx1, ptr %out0, ptr %out1) {
; CHECK-LABEL: overlapping_chains(
; CHECK:       {
; CHECK-NEXT:    .local .align 4 .b8 __local_depot9[32];
; CHECK-NEXT:    .reg .b64 %SP;
; CHECK-NEXT:    .reg .b64 %SPL;
; CHECK-NEXT:    .reg .b32 %r<7>;
; CHECK-NEXT:    .reg .b64 %rd<14>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %SPL, __local_depot9;
; CHECK-NEXT:    cvta.local.u64 %SP, %SPL;
; CHECK-NEXT:    ld.param.b32 %rd1, [overlapping_chains_param_0];
; CHECK-NEXT:    and.b64 %rd2, %rd1, 3;
; CHECK-NEXT:    shl.b64 %rd3, %rd2, 2;
; CHECK-NEXT:    add.u64 %rd4, %SP, 16;
; CHECK-NEXT:    add.s64 %rd5, %rd4, %rd3;
; CHECK-NEXT:    st.b32 [%rd5], 10;
; CHECK-NEXT:    add.u64 %rd6, %SP, 0;
; CHECK-NEXT:    add.s64 %rd7, %rd6, %rd3;
; CHECK-NEXT:    ld.b32 %r1, [%SP+28];
; CHECK-NEXT:    ld.b32 %r2, [%SP+16];
; CHECK-NEXT:    ld.param.b64 %rd8, [overlapping_chains_param_2];
; CHECK-NEXT:    st.b32 [%rd7], 10;
; CHECK-NEXT:    ld.param.b32 %rd9, [overlapping_chains_param_1];
; CHECK-NEXT:    and.b64 %rd10, %rd9, 3;
; CHECK-NEXT:    shl.b64 %rd11, %rd10, 2;
; CHECK-NEXT:    add.s64 %rd12, %rd6, %rd11;
; CHECK-NEXT:    st.b32 [%SP+4], 20;
; CHECK-NEXT:    st.b32 [%rd12], 30;
; CHECK-NEXT:    ld.param.b64 %rd13, [overlapping_chains_param_3];
; CHECK-NEXT:    ld.b32 %r3, [%SP+12];
; CHECK-NEXT:    ld.b32 %r4, [%SP+8];
; CHECK-NEXT:    ld.b32 %r5, [%SP+4];
; CHECK-NEXT:    ld.b32 %r6, [%SP];
; CHECK-NEXT:    st.v4.b32 [%rd8], {%r2, 20, 40, %r1};
; CHECK-NEXT:    st.v4.b32 [%rd13], {%r6, %r5, %r4, %r3};
; CHECK-NEXT:    ret;
  %v0 = insertelement <4 x i32> poison, i32 10, i32 %idx0
  %v1 = insertelement <4 x i32> %v0, i32 20, i32 1

  ; Chain 2 starts from v1
  %w0 = insertelement <4 x i32> %v1, i32 30, i32 %idx1

  ; Continue chain 1
  %v2 = insertelement <4 x i32> %v1, i32 40, i32 2

  store <4 x i32> %v2, ptr %out0
  store <4 x i32> %w0, ptr %out1
  ret void
}
